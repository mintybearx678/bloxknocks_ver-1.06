<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BloxKnocks - Beta VER 1.0.6</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud { pointer-events: auto; color: white; text-shadow: 2px 2px 4px #000; position: absolute; font-weight: bold; }
        #crosshair { top: 50%; left: 50%; width: 6px; height: 6px; background: white; border-radius: 50%; transform: translate(-50%, -50%); position: absolute; border: 1px solid black; }
        #fps-counter { top: 20px; right: 20px; font-family: monospace; color: #00ff00; font-size: 18px; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px; }
        #score-display { top: 20px; left: 20px; font-size: 28px; }
        #health-bar-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 300px; height: 12px; background: rgba(0,0,0,0.8); border: 2px solid #222; }
        #health-fill { width: 100%; height: 100%; background: #00ff00; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; }
        .menu-box { background: #222; padding: 25px; border-radius: 5px; border: 3px solid #fff; text-align: center; min-width: 300px; }
        .btn { background: #fff; color: black; border: none; padding: 12px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; text-transform: uppercase; }
        select { background: #444; color: white; padding: 8px; width: 100%; margin: 5px 0 10px 0; }
        #pause-menu, #game-over { display: none; }
    </style>
</head>
<body>

    <div id="start-screen" class="overlay">
        <div class="menu-box">
            <h1 style="color:#00ffcc;">BLOXKNOCKS</h1>
            <p>WASD: Move | SPACE: Jump<br>Yellow Cube: TRIPLE SHOT</p>
            <button class="btn" id="start-btn">Deploy</button>
        </div>
    </div>

    <div id="pause-menu" class="overlay">
        <div class="menu-box">
            <h2>SETTINGS</h2>
            <label>Vibrant Visuals:</label>
            <select id="graphics-select">
                <option value="low">Standard</option>
                <option value="high" selected>High (Vibrant)</option>
            </select>
            <label>FPS Uncapper:</label>
            <select id="fps-select">
                <option value="60">60 FPS</option>
                <option value="120">120 FPS</option>
                <option value="30">30 FPS</option>
            </select>
            <button class="btn" id="resume-btn">Resume</button>
        </div>
    </div>

    <div id="game-over" class="overlay">
        <div class="menu-box"><h1>WASTED</h1><button class="btn" onclick="location.reload()">Respawn</button></div>
    </div>

    <div id="ui-layer">
        <div id="fps-counter" class="hud">FPS: 0</div>
        <div id="score-display" class="hud">KILLS: <span id="score">0</span></div>
        <div id="crosshair"></div>
        <div id="health-bar-container"><div id="health-fill"></div></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- TEXTURE ---
        function createFloorTex() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#6d4c41'; ctx.fillRect(0,0,256,256);
            ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1;
            for(let i=0; i<30; i++) { ctx.beginPath(); ctx.moveTo(Math.random()*256, Math.random()*256); ctx.lineTo(Math.random()*256, Math.random()*256); ctx.stroke(); }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(60, 60);
            return tex;
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, precision: 'lowp' }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 1.0); scene.add(ambient); // Increased for Minecraft vibrancy
        const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(10, 20, 10); scene.add(sun);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(600, 600), new THREE.MeshLambertMaterial({ map: createFloorTex() }));
        ground.rotation.x = -Math.PI / 2; scene.add(ground);

        // --- PLAYER ---
        const player = new THREE.Group(); scene.add(player);
        const camPivot = new THREE.Group(); camPivot.position.y = 1.6; player.add(camPivot); camPivot.add(camera);
        
        const gun = new THREE.Group();
        const gBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.5), new THREE.MeshLambertMaterial({color: 0x222}));
        const gBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4), new THREE.MeshLambertMaterial({color: 0x111}));
        gBarrel.rotation.x = Math.PI/2; gBarrel.position.z = -0.3; gun.add(gBody, gBarrel);
        gun.position.set(0.3, -0.3, -0.5); camPivot.add(gun);

        // --- STATE & POWERUP ---
        let gameActive = false, health = 100, score = 0, fpsCap = 60;
        let isAiming = false, targetFov = 75, vY = 0, onGround = true;
        let powerUpTime = 0; 
        const keys = {}, bullets = [], enemies = [], powerUps = [];

        // --- RESTORED GUN SFX ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playPew() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(450, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            g.gain.setValueAtTime(0.08, audioCtx.currentTime); 
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        // --- HELPERS ---
        function createBullet(offsetDir = 0) {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0xffff00}));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if(offsetDir !== 0) dir.applyAxisAngle(new THREE.Vector3(0,1,0), offsetDir);
            b.position.copy(player.position).y += 1.6;
            b.velocity = dir.multiplyScalar(2.0); b.life = 60;
            bullets.push(b); scene.add(b);
        }

        function spawnPowerUp() {
            const p = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color: 0xffff00}));
            p.position.set((Math.random()-0.5)*50, 0.5, (Math.random()-0.5)*50);
            powerUps.push(p); scene.add(p);
        }

        // --- INPUTS ---
        document.getElementById('start-btn').onclick = () => { gameActive = true; document.getElementById('start-screen').style.display='none'; document.body.requestPointerLock(); };
        document.getElementById('resume-btn').onclick = () => document.body.requestPointerLock();
        document.getElementById('graphics-select').onchange = (e) => { 
            const high = e.target.value === 'high';
            sun.intensity = high ? 1.5 : 0.8; 
            ambient.intensity = high ? 1.2 : 0.6; 
        };
        document.getElementById('fps-select').onchange = (e) => fpsCap = parseInt(e.target.value);
        
        document.addEventListener('pointerlockchange', () => {
            const p = document.pointerLockElement !== document.body;
            if(gameActive) document.getElementById('pause-menu').style.display = p ? 'flex' : 'none';
        });

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { if(document.pointerLockElement === document.body) {
            const s = isAiming ? 0.001 : 0.0025; player.rotation.y -= e.movementX * s;
            camPivot.rotation.x = Math.max(-1.4, Math.min(1.4, camPivot.rotation.x - e.movementY * s));
        }});
        window.addEventListener('mousedown', e => {
            if(!gameActive || document.pointerLockElement !== document.body) return;
            if(e.button === 0) {
                playPew(); createBullet(0);
                if(powerUpTime > 0) { createBullet(0.15); createBullet(-0.15); }
            }
            if(e.button === 2) { isAiming = true; targetFov = 40; }
        });
        window.addEventListener('mouseup', e => { if(e.button === 2) { isAiming = false; targetFov = 75; }});
        window.addEventListener('contextmenu', e => e.preventDefault());

        function spawnEnemy() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.4, 1.2), new THREE.MeshLambertMaterial({color: 0xff0000}));
            
            // HP Bar Background
            const hbBg = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.2), new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide}));
            hbBg.position.y = 1.8;
            
            // HP Bar Fill
            const hbFill = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.2), new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide}));
            hbFill.position.y = 1.8; hbFill.position.z = 0.02;
            
            group.add(body, hbBg, hbFill);
            const a = Math.random()*Math.PI*2;
            group.position.set(player.position.x+Math.cos(a)*40, 1.2, player.position.z+Math.sin(a)*40);
            group.hp = 100; group.hpFill = hbFill;
            enemies.push(group); scene.add(group);
        }

        // --- MAIN LOOP ---
        let lastF = performance.now(), frames = 0;
        function loop() {
            setTimeout(() => requestAnimationFrame(loop), 1000 / fpsCap);
            const now = performance.now(); frames++;
            if (now > lastF + 1000) { document.getElementById('fps-counter').innerText = "FPS: " + frames; frames = 0; lastF = now; }
            if(!gameActive || document.pointerLockElement !== document.body) { renderer.render(scene, camera); return; }

            // Jump & Physics
            vY -= 0.012; player.position.y += vY;
            if(player.position.y <= 0) { player.position.y = 0; vY = 0; onGround = true; }
            if(keys['Space'] && onGround) { vY = 0.25; onGround = false; }

            // Movement
            const s = isAiming ? 0.08 : 0.2;
            const f = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            const r = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            if(keys['KeyW']) player.position.add(f.multiplyScalar(s));
            if(keys['KeyS']) player.position.add(f.multiplyScalar(-s));
            if(keys['KeyA']) player.position.add(r.multiplyScalar(-s));
            if(keys['KeyD']) player.position.add(r.multiplyScalar(s));

            // Powerup Logic
            if(powerUpTime > 0) powerUpTime--;
            powerUps.forEach((p, i) => {
                p.rotation.y += 0.05;
                if(p.position.distanceTo(player.position) < 2) { scene.remove(p); powerUps.splice(i,1); powerUpTime = 300; }
            });

            // Bullets
            bullets.forEach((b, i) => {
                b.position.add(b.velocity);
                if(--b.life <= 0) { scene.remove(b); bullets.splice(i,1); }
                enemies.forEach((e, j) => {
                    if(b.position.distanceTo(e.position) < 1.6) {
                        e.hp -= 34; 
                        e.hpFill.scale.x = Math.max(0.01, e.hp/100); // Visual shrink
                        scene.remove(b); bullets.splice(i,1);
                        if(e.hp <= 0) { scene.remove(e); enemies.splice(j,1); score++; document.getElementById('score').innerText = score; }
                    }
                });
            });

            // Enemies behavior
            enemies.forEach(e => {
                e.lookAt(player.position.x, 1.2, player.position.z);
                const d = player.position.clone().sub(e.position).normalize();
                e.position.add(d.multiplyScalar(0.08));
                if(e.position.distanceTo(player.position) < 2) {
                    health -= 0.5; document.getElementById('health-fill').style.width = health + "%";
                    if(health <= 0) { gameActive = false; document.getElementById('game-over').style.display='flex'; }
                }
            });

            camera.fov += (targetFov - camera.fov) * 0.2; camera.updateProjectionMatrix();
            if(Math.random() < 0.01 && enemies.length < 15) spawnEnemy();
            if(Math.random() < 0.002 && powerUps.length < 2) spawnPowerUp();
            renderer.render(scene, camera);
        }
        loop();
    </script>
</body>
</html>